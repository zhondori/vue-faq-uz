import{_ as a,o as i,c as e,a9 as s}from"./chunks/framework.HokEyLHe.js";const k=JSON.parse('{"title":"Frontend freymvorklar haqida","description":"","frontmatter":{},"headers":[],"relativePath":"uz/frontend/about-frameworks.md","filePath":"uz/frontend/about-frameworks.md","lastUpdated":1714966705000}'),t={name:"uz/frontend/about-frameworks.md"},o=s(`<h1 id="frontend-freymvorklar-haqida" tabindex="-1">Frontend freymvorklar haqida <a class="header-anchor" href="#frontend-freymvorklar-haqida" aria-label="Permalink to &quot;Frontend freymvorklar haqida&quot;">​</a></h1><details class="details custom-block"><summary>&quot;reaktivlik&quot; nima?</summary><p>Ehtimol, frontend dasturi va backend dasturi, mikroservis yoki hatto GUI ilovasi o&#39;rtasidagi eng asosiy farq bu &quot;<strong>reaktivlik</strong>&quot; tushunchasi.</p><p>Bekend tomonda ishlaganda, dasturchi ma&#39;lumotlar oqimini qanday boshqarishi aniqroq. U uni qayerdan olish, qayerga jo‘natish, kim o‘zgartirishi mumkinligini belgilash, bularning barchasi bitta thread yoki multithread tizimda</p><p>Front tomonda UI interaktivlik omili katta rol o&#39;ynaydi - ma&#39;lumotlar foydalanuvchiga dinamik ravishda ko&#39;rsatilishi kerak, foydalanuvchi ma&#39;lumotlarni o&#39;zgartirishi mumkin, ma&#39;lumotlarni turli pudratchilar (foydalanuvchi, backend, ichki hisoblar) o&#39;zgartirishi mumkin. Printsipial jihatdan, oddiy backend&#39;dagi kabi dasturlash yondashuvlaridan foydalanish mumkin, ya&#39;ni har bir joyda ma&#39;lumotlar o&#39;zgarishini o&#39;zingiz kuzatib borasiz va barcha o&#39;zgarishlarni qo&#39;lda amalga oshirasiz. Bu juda ko&#39;p boilerplate - muntazam, takrorlanadigan kodga olib keladi. Reaktiv freymvorklar o&#39;zgaruvchilar o&#39;zgarganda yangilanishi avtomatik bajarib, dasturchilar uchun hayotni ancha osonlashtirdi.</p><p>Reaktiv freymvorklarda reaktiv o&#39;zgaruvchini yaratish va u, masalan, input&#39;ning qiymati ekanligini ko&#39;rsatish kifoya. Foydalanuvchi ushbu maydonga qiymat kiritganda, o&#39;zgaruvchi avtomatik ravishda yangilanadi va unga bog&#39;liq bo&#39;lgan barcha boshqa o&#39;zgaruvchilar ham yangilanadi. Buning uchun qo&#39;shimcha kod yozishingiz shart emas.</p><p>Oddiy qilib aytganda, reaktiv o&#39;zgaruvchi oddiy o&#39;zgaruvchiga nisbatan proksi&#39;ga o&#39;ralgan bo&#39;lib, uning o&#39;zgarishlarini kuzatib boradi va o&#39;zgaruvchi o&#39;zgarganda xabardor qilinishi kerak bo&#39;lgan barcha narsalarni qiymatni qayta hisoblashi uchun qayta chaqirib yuboradi.</p></details><details class="details custom-block"><summary>Qanday reaktiv frontend freymvorklar mavjud?</summary><p>React, Vue, Angular eng keng tarqalganlari. Yana ko&#39;p boshqa freymvorklar bor lekin uncha mashhur emas</p><p>Angular odatda yirik loyihalar (turli darajadagi dasturchilarning katta guruhlari) uchun ishlatiladi va ishlab chiqish jarayonini o&#39;z qoidalariga mahkam bog&#39;laydi.</p><p>React va Vue moslashuvchan va o&#39;xshash, lekin orasida sezilarli darajada farq bor.</p><p>Vue tez, hajmi kichikroq, samaraliroq, HTML va JS&#39;ni aralashtirib yubormaydi, o&#39;rganishga osonroq. Faol rivojlanyapti.</p><p>React&#39;ni orqasida - Zukerberg va keng tarqalganligi. Vakansiyalar ko&#39;p, lekin vakansiyaga topshiruvchilar.</p></details><details class="details custom-block"><summary>Nega Vue?</summary><p>To be able to develop and manage large complex software systems, OOP - object-oriented programming - was invented, where new entities - objects - were introduced to hierarchize complexity. They encapsulated data and behavior (logic).</p><p>On the frontend, the situation is a bit different due to the presence of code in several programming languages - HTML, CSS, JavaScript. And in this case, the SFC components in Vue serve perfectly to break down the complexity of the system. Each component encapsulates the HTML template, its styling and logic.</p><p>Vue does this much better than the same React, which lumps everything together. In this aspect, Vue is unequivocally the flagship of component-oriented programming (COP) on the frontend.</p><p>In addition, Vue 3 introduced reactivity beyond components - <code>ref</code> and <code>reactive</code> variables can be set in a simple <code>js</code> module. This is used in <code>composable</code> functions. It has become possible to separate not only the reactive service (<code>useI18n</code>, <code>useScreenSize</code> for example) but also the business logic (<code>useShoppingCart</code>, <code>useNewsWidget</code>) from the view. This allows to use <a href="https://ru.wikipedia.org/wiki/Model-View-Controller" target="_blank" rel="noreferrer">MVC pattern</a> on the frontend, where the roles of <code>View</code> and partially <code>Controller</code> are performed by components responsible mainly for visualization, and the logic and model (<code>Model</code> and partially <code>Controller</code>) fall on composable functions and their reactive state.</p><p>This makes it possible to make, for example, changing the site design or replacing the UI library a much easier task.</p><p>This feature also makes Vue stand out from other reactive frameworks.</p><p>The Reactivity API in Vue 3 may not be perfect yet (which is why creator of the Vue.js Evan You has been experimenting with Reactivity Transform), but it&#39;s already quite suitable for developing large, robust, scalable systems, which was not the case with Vue 2.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Vue&#39;s reactivity can be used without UIs at all. For example, <a href="https://github.com/soerenuhrbach/vscode-deepl/blob/main/src/state.ts" target="_blank" rel="noreferrer">this VS Code extension</a> uses the Vue 3 elements <code>reactive</code>, <code>ref</code>, and <code>watch</code> to organize reactivity in code without visual components.</p></div></details><details class="details custom-block"><summary>Vue, React yoki Svelte bajara olmaydigan nima qila oladi?</summary><p>Vue reaktiv ma&#39;lumotlar bilan samaraliroq ishlaydi.</p><p>Massivga yangi element qo&#39;shish:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// React</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setSomeArr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">someArr, newItem]);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Svelte</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">someArr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">someArr, newItem];</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Vue</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">someArr.value.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newItem.value);</span></span></code></pre></div><p>ES6 native proksi obyektidan foydalanish massivni yoyib yuborish va oraliq massiv yaratishdan saqlaydi. Bundan tashqari, u yanada tezroq ishlaydi.</p></details>`,5),r=[o];function n(l,h,d,c,p,u){return i(),e("div",null,r)}const g=a(t,[["render",n]]);export{k as __pageData,g as default};
